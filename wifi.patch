diff --git a/src/main.cpp b/src/main.cpp
index 4afe8b0..effdf23 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,6 +1,6 @@
 #define ZEDMD_VERSION_MAJOR 3 // X Digits
 #define ZEDMD_VERSION_MINOR 3 // Max 2 Digits
-#define ZEDMD_VERSION_PATCH 1 // Max 2 Digits
+#define ZEDMD_VERSION_PATCH 2 // Max 2 Digits
 
 #ifdef ZEDMD_128_64_2
 #define PANEL_WIDTH 128 // Width: number of LEDs for 1 panel.
@@ -58,6 +58,7 @@
 // 26: turn on flow control version 2
 // 27: set WiFi SSID
 // 28: set WiFi password
+// 29: set WiFi port
 // 30: save settings
 // 31: reset
 // 32: get version string, returns (int8) major, (int8) minor, (int8) patch level
@@ -82,13 +83,30 @@
 #include <WiFi.h>
 #include <AsyncUDP.h>
 
-const char *ssid = "****";
-const char *pwd = "****";
-
-uint8_t udpCurrentFrameId = 255;
+String ssid;
+String pwd;
+uint16_t port;
 
 AsyncUDP udp;
 IPAddress ip;
+
+unsigned long rotNextRotationTime[1];
+#else
+#ifdef ZEDMD_128_64_2
+uint8_t doubleBuffer[TOTAL_HEIGHT][TOTAL_WIDTH] = {0};
+uint8_t existsBuffer[TOTAL_HEIGHT][TOTAL_WIDTH / 2] = {0};
+#else
+uint8_t doubleBuffer[TOTAL_BYTES] = {0};
+#endif
+
+// color rotation
+unsigned char rotFirstColor[MAX_COLOR_ROTATIONS];
+unsigned char rotAmountColors[MAX_COLOR_ROTATIONS];
+unsigned int rotStepDurationTime[MAX_COLOR_ROTATIONS];
+unsigned long rotNextRotationTime[MAX_COLOR_ROTATIONS];
+unsigned char tmpColor[3] = { 0 };
+
+bool upscaling = true;
 #endif
 
 // Pinout derived from ESP32-HUB75-MatrixPanel-I2S-DMA.h
@@ -150,23 +168,7 @@ unsigned char *palette;
 unsigned char *renderBuffer;
 uint8_t renderBufferInUse = 0; // 0: not used; 1: USB; 2: WiFi
 
-#ifdef ZEDMD_128_64_2
-uint8_t doubleBuffer[TOTAL_HEIGHT][TOTAL_WIDTH] = {0};
-uint8_t existsBuffer[TOTAL_HEIGHT][TOTAL_WIDTH / 2] = {0};
-#else
-uint8_t doubleBuffer[TOTAL_BYTES] = {0};
-#endif
-
-// color rotation
-unsigned char rotFirstColor[MAX_COLOR_ROTATIONS];
-unsigned char rotAmountColors[MAX_COLOR_ROTATIONS];
-unsigned int rotStepDurationTime[MAX_COLOR_ROTATIONS];
-unsigned long rotNextRotationTime[MAX_COLOR_ROTATIONS];
-unsigned char tmpColor[3] = { 0 };
-
-
 bool mode64 = false;
-bool upscaling = true;
 
 int RomWidth = 128, RomHeight = 32;
 int RomWidthPlane = 128 >> 3;
@@ -297,15 +299,17 @@ void ClearScreen()
 {
   dma_display->clearScreen();
   dma_display->setBrightness8(lumval[lumstep]);
-
+#ifndef ZEDMD_WIFI
 #ifdef ZEDMD_128_64_2
   memset(doubleBuffer, 0, TOTAL_HEIGHT * TOTAL_WIDTH);
   memset(existsBuffer, 0, TOTAL_HEIGHT * TOTAL_WIDTH / 2);
 #else
   memset(doubleBuffer, 0, TOTAL_BYTES);
 #endif
+#endif
 }
 
+#ifndef ZEDMD_WIFI
 bool CmpColor(uint8_t *px1, uint8_t *px2, uint8_t colors)
 {
   if (colors == 3)
@@ -610,9 +614,11 @@ void ScaleImage(uint8_t colors)
 
   free(panel);
 }
+#endif
 
 void DrawPixel(int x, int y, uint8_t r, uint8_t g, uint8_t b)
 {
+#ifndef ZEDMD_WIFI
 #ifdef ZEDMD_128_64_2
   uint8_t colors = ((r >> 5) << 5) + ((g >> 5) << 2) + (b >> 6);
   uint8_t colorsExist = (r ? 8 : 0) + (g ? 4 : 0) + (b ? 2 : 0) + ((r || g || b) ? 1 : 0);
@@ -631,8 +637,31 @@ void DrawPixel(int x, int y, uint8_t r, uint8_t g, uint8_t b)
     doubleBuffer[pos + 1] = g;
     doubleBuffer[pos + 2] = b;
 #endif
-
+#endif
     dma_display->drawPixelRGB888(x, y, r, g, b);
+#ifndef ZEDMD_WIFI
+  }
+#endif
+}
+
+void fillZoneRaw(uint8_t idx)
+{
+  uint8_t yOffset = idx / (TOTAL_WIDTH / 16) * 8;
+  uint8_t xOffset = (idx % (TOTAL_WIDTH / 16)) * 16;
+
+  for (int y = 0; y < 8; y++)
+  {
+    for (int x = 0; x < 16; x++)
+    {
+      uint16_t pos = (y * 16 + x) * 3;
+
+      DrawPixel(
+          x + xOffset,
+          y + yOffset,
+          renderBuffer[pos + ordreRGB[acordreRGB * 3]],
+          renderBuffer[pos + ordreRGB[acordreRGB * 3 + 1]],
+          renderBuffer[pos + ordreRGB[acordreRGB * 3 + 2]]);
+    }
   }
 }
 
@@ -676,6 +705,7 @@ void fillPanelUsingPalette()
   }
 }
 
+#ifndef ZEDMD_WIFI
 void fillPanelUsingChangedPalette(bool *paletteAffected)
 {
   int pos;
@@ -698,6 +728,7 @@ void fillPanelUsingChangedPalette(bool *paletteAffected)
     }
   }
 }
+#endif
 
 void LoadOrdreRGB()
 {
@@ -731,6 +762,36 @@ void SaveLum()
   flum.close();
 }
 
+#ifdef ZEDMD_WIFI
+bool LoadWiFiConfig()
+{
+  File wifiConfig = LittleFS.open("/wifi_config.txt", "r");
+  if (!wifiConfig)
+    return false;
+
+  while(wifiConfig.available()){
+    ssid = wifiConfig.readStringUntil('\n');
+    pwd = wifiConfig.readStringUntil('\n');
+    port = wifiConfig.read();
+  }
+  wifiConfig.close();
+  return true;
+}
+
+bool SaveWiFiConfig()
+{
+  File wifiConfig = LittleFS.open("/wifi_config.txt", "w");
+  if (!wifiConfig)
+    return false;
+
+  wifiConfig.println(ssid);
+  wifiConfig.println(pwd);
+  wifiConfig.write(port);
+  wifiConfig.close();
+  return true;
+}
+#endif
+
 void ledTester(void)
 {
   uint8_t col[3] = { 255,0,0 };
@@ -899,74 +960,76 @@ void setup()
   DisplayLogo();
 
 #ifdef ZEDMD_WIFI
-  WiFi.disconnect(true);
-  // register event handler
-  WiFi.onEvent(WiFiEvent);
-
-  // Initiate connection
-  WiFi.begin(ssid, pwd);
-
-  uint8_t result = WiFi.waitForConnectResult();
-
-  if(udp.listen(3333)) {
-    udp.onPacket([](AsyncUDPPacket packet) {
-      if (packet.length() >= 2) {
-        if (MireActive) {
-          ClearScreen();
-          MireActive = false;
-        }
-
-        if (renderBufferInUse == 0) {
-          renderBuffer = (uint8_t*)malloc(TOTAL_BYTES);
-          memset(renderBuffer, 0, TOTAL_BYTES);
-          renderBufferInUse = 2;
-        }
-        else if (renderBufferInUse == 1) {
-          // Blocked by rendering over USB.
-          return;
-        }
+  if (LoadWiFiConfig())
+  {
+    WiFi.disconnect(true);
+    // register event handler
+    WiFi.onEvent(WiFiEvent);
+
+    // Initiate connection
+    //WiFi.begin(ssid.c_str(), pwd.c_str());
+    WiFi.begin("WLAN-MKalkbrenner", "PulpFiction!");
+
+    uint8_t result = WiFi.waitForConnectResult();
+    if(udp.listen(3333)) {
+      udp.onPacket([](AsyncUDPPacket packet) {
+        if (packet.length() >= 2) {
+          if (MireActive) {
+            ClearScreen();
+            MireActive = false;
+          }
 
-        uint8_t *pPacket = packet.data();
-        uint8_t compressed = pPacket[1] & 128;
-        uint8_t render = pPacket[1] & 64;
-        uint8_t frameId = pPacket[1] & 63;
-
-        if (render == 64) {
-          if (frameId == udpCurrentFrameId) {
-            fillPanelRaw();
-            udpCurrentFrameId++;
-            if (udpCurrentFrameId >= 64) {
-              udpCurrentFrameId = 0;
-            }
+          if (renderBufferInUse == 0) {
+            renderBufferInUse = 2;
+          }
+          else if (renderBufferInUse == 1) {
+            // Blocked by rendering over USB.
+            return;
           }
-          return;
-        }
-        else if (frameId != udpCurrentFrameId) {
-          fillPanelRaw();
-          udpCurrentFrameId = frameId;
-        }
 
-        if (frameId == udpCurrentFrameId)
-        {
-          if (compressed == 128)
+          uint8_t *pPacket = packet.data();
+          switch (pPacket[0])
           {
-            mz_ulong uncompressedBufferSize;
-            mz_ulong udpPayloadSize = packet.length() - 3;
+            case 10: // clear screen
+            {
+              ClearScreen();
+              break;
+            }
 
-            int status = mz_uncompress2(&renderBuffer[pPacket[2] * TOTAL_WIDTH * 3], &uncompressedBufferSize, pPacket + 3, (mz_ulong *)&udpPayloadSize);
-            if (status != MZ_OK)
+            case 3: // RGB24
             {
-              int tmp_status = (status >= 0) ? status : (-1 * status) + 100;
-              Say(0, tmp_status);
+              uint8_t compressed = pPacket[1] & 128;
+              uint8_t idx = pPacket[1] & 127;
+              int size = (int)(pPacket[3]) + (((int)pPacket[2]) << 8);
+
+              renderBuffer = (uint8_t*)malloc(16 * 8 * 3);
+              
+              if (compressed == 128)
+              {
+                mz_ulong uncompressedBufferSize = 16 * 8 * 3;
+                mz_ulong udpPayloadSize = (mz_ulong) size;
+
+                int status = mz_uncompress2(renderBuffer, &uncompressedBufferSize, &pPacket[4], (mz_ulong *)&udpPayloadSize);
+                if (status != MZ_OK || uncompressedBufferSize != 16 * 8 * 3)
+                {
+                  int tmp_status = (status >= 0) ? status : (-1 * status) + 100;
+                  if (debugMode) Say(0, tmp_status);
+                  return;
+                }
+              }
+              else
+              {
+                memcpy(renderBuffer, &pPacket[4], size);
+              }
+
+              fillZoneRaw(idx); 
+              free(renderBuffer);
+              break;
             }
           }
-          else
-          {
-            memcpy(&renderBuffer[pPacket[2] * TOTAL_WIDTH * 3], pPacket + 3, packet.length() - 3);
-          }
         }
-      }
-    });
+      });
+    }
   }
 #endif
 }
@@ -1094,6 +1157,7 @@ bool SerialReadBuffer(unsigned char *pBuffer, unsigned int BufferSize)
 
 void updateColorRotations(void)
 {
+#ifndef ZEDMD_WIFI
   bool rotPaletteAffected[64] = { 0 };
   unsigned long actime = millis();
   bool rotfound = false;
@@ -1119,6 +1183,7 @@ void updateColorRotations(void)
 
   if (rotfound == true)
     fillPanelUsingChangedPalette(rotPaletteAffected);
+#endif
 }
 
 bool wait_for_ctrl_chars(void)
@@ -1328,10 +1393,12 @@ void loop()
 
       case 16:
       {
+        Serial.write('A');
         ledTester();
         break;
       }
 
+#ifndef ZEDMD_WIFI
       case 20: // turn off upscaling
       {
         upscaling = false;
@@ -1343,6 +1410,7 @@ void loop()
         upscaling = true;
         Serial.write('A');
         break;
+#endif
 
       case 22: // set brightness
       {
@@ -1353,6 +1421,7 @@ void loop()
           {
             lumstep = tbuf[0];
             dma_display->setBrightness8(lumval[lumstep]);
+            Serial.write('A');
           }
           else
           {
@@ -1370,6 +1439,7 @@ void loop()
           if (tbuf[0] >= 0 && tbuf[0] < 6)
           {
             acordreRGB = tbuf[0];
+            Serial.write('A');
           }
           else
           {
@@ -1398,19 +1468,79 @@ void loop()
         break;
       }
 
+#ifdef ZEDMD_WIFI
+      // These are one time programmig options over USB until ZeDMD could establish
+      // the WiFi Connection at startup. When WiFi is finally active, USB is turned off.
+      case 27: // set WiFi SSID
+      {
+        unsigned char tbuf[129];
+        if (SerialReadBuffer(tbuf, 129))
+        {
+          // tbuf[0] now contains the length of the string
+          unsigned char *tmp = (unsigned char *)malloc(tbuf[0]);
+          memcpy(tmp, &tbuf[1], tbuf[0]);
+          ssid = (const char*) tmp;
+          free(tmp);
+          Serial.write('A');
+        }
+        else
+        {
+          Serial.write('E');
+        }
+      }
+
+      case 28: // set WiFi password
+      {
+        unsigned char tbuf[129];
+        if (SerialReadBuffer(tbuf, 129))
+        {
+          // tbuf[0] now contains the length of the string
+          unsigned char *tmp = (unsigned char *)malloc(tbuf[0]);
+          memcpy(tmp, &tbuf[1], tbuf[0]);
+          pwd = (const char*) tmp;
+          free(tmp);
+          Serial.write('A');
+        }
+        else
+        {
+          Serial.write('E');
+        }
+        break;
+      }
+
+      case 29: // set WiFi port
+      {
+        uint8_t byteArray[2];
+        if (Serial.readBytes(byteArray, 2))
+        {
+          port = ((((unsigned int)byteArray[0]) << 8) +
+                 ((unsigned int)byteArray[1]));
+          Serial.write('A');
+        }
+        else
+        {
+          Serial.write('E');
+        }
+        break;
+      }
+#endif
+
       case 30: // save settings
       {
+        Serial.write('A');
         SaveLum();
         SaveOrdreRGB();
-        Serial.write('A');
+#ifdef ZEDMD_WIFI
+        SaveWiFiConfig();
+#endif
         break;
       }
 
       case 31: // reset
       {
+        Serial.write('A');
         handshakeSucceeded = false;
         DisplayLogo();
-        Serial.write('A');
         break;
       }
 
@@ -1454,13 +1584,14 @@ void loop()
 
       case 10: // clear screen
       {
+        Serial.write('A');
         ClearScreen();
         displayStatus = 3;
         rotNextRotationTime[0] = millis();
-        Serial.write('A');
         break;
       }
 
+#ifndef ZEDMD_WIFI
       case 3: // mode RGB24
       {
         // We need to cover downscaling, too.
@@ -1791,7 +1922,7 @@ void loop()
         }
         break;
       }
-
+#endif
       default:
       {
         Serial.write('E');
